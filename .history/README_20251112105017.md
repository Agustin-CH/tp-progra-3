# ğŸ´ Knight's Tour Problem - Trabajo PrÃ¡ctico ProgramaciÃ³n 3

## ğŸ“‹ DescripciÃ³n del Proyecto

Este proyecto implementa **tres soluciones diferentes** al problema clÃ¡sico del **Knight's Tour** (Recorrido del Caballo) en Java, con una interfaz web interactiva para visualizar y comparar los algoritmos.

**Trabajo PrÃ¡ctico Obligatorio - ProgramaciÃ³n 3 - UADE 2025**

### Objetivos del Proyecto

1. **Implementar y comparar diferentes tÃ©cnicas algorÃ­tmicas:**
   - Backtracking (bÃºsqueda exhaustiva)
   - HeurÃ­stica Greedy (Regla de Warnsdorff)
   - ProgramaciÃ³n DinÃ¡mica (maximizaciÃ³n de puntos)

2. **Analizar complejidad temporal y espacial** de cada algoritmo

3. **Crear una aplicaciÃ³n web funcional** que demuestre los conceptos de forma visual e interactiva

## TecnologÃ­as Utilizadas

### Backend
- **Java 17**
- **Spring Boot 3.1.5** - Framework web
- **Maven** - GestiÃ³n de dependencias

### Frontend
- **HTML5**
- **CSS3** (diseÃ±o responsive y moderno)
- **JavaScript Vanilla** (sin frameworks)

## Estructura del Proyecto

```
Tp-progra-iii/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/com/uade/progra3/knightstour/
â”‚   â”‚   â”‚   â”œâ”€â”€ KnightsTourApplication.java      # Clase principal
â”‚   â”‚   â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ KnightsTourController.java   # REST API
â”‚   â”‚   â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BacktrackingService.java     # Algoritmo Backtracking
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ WarnsdorffService.java       # Algoritmo Greedy
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ DynamicProgrammingService.java # Algoritmo PD
â”‚   â”‚   â”‚   â””â”€â”€ model/
â”‚   â”‚   â”‚       â”œâ”€â”€ Position.java
â”‚   â”‚   â”‚       â”œâ”€â”€ SolutionResult.java
â”‚   â”‚   â”‚       â”œâ”€â”€ ComplexityAnalysis.java
â”‚   â”‚   â”‚       â””â”€â”€ DynamicProgrammingRequest.java
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚       â”œâ”€â”€ static/
â”‚   â”‚       â”‚   â”œâ”€â”€ index.html                   # Frontend
â”‚   â”‚       â”‚   â”œâ”€â”€ styles.css
â”‚   â”‚       â”‚   â””â”€â”€ script.js
â”‚   â”‚       â””â”€â”€ application.properties
â”œâ”€â”€ pom.xml                                       # ConfiguraciÃ³n Maven
â””â”€â”€ README.md
```

## InstalaciÃ³n y EjecuciÃ³n

### Prerequisitos

- **Java 17 o superior**
- **Maven 3.6+** (o usar el wrapper incluido)
- **Navegador web moderno**

### Pasos para ejecutar el proyecto

1. **Clonar o descargar el repositorio**

```bash
cd Tp-progra-iii
```

2. **Compilar el proyecto**

```bash
mvn clean install
```

3. **Ejecutar la aplicaciÃ³n**

```bash
mvn spring-boot:run
```

O alternativamente:

```bash
java -jar target/knights-tour-1.0.0.jar
```

4. **Abrir en el navegador**

```
http://localhost:8080
```

La aplicaciÃ³n estarÃ¡ corriendo en el puerto **8080**.

## CÃ³mo Usar la AplicaciÃ³n

### Interfaz Web

1. **Seleccionar un algoritmo:**
   - Backtracking
   - Warnsdorff (Greedy)
   - ProgramaciÃ³n DinÃ¡mica
   - Comparar Algoritmos

2. **Configurar parÃ¡metros:**
   - TamaÃ±o del tablero (4Ã—4 hasta 12Ã—12)
   - PosiciÃ³n inicial del caballo
   - Para PD: nÃºmero de movimientos

3. **Hacer clic en "Resolver"**

4. **Visualizar resultados:**
   - Tablero con el recorrido numerado
   - MÃ©tricas de rendimiento
   - AnÃ¡lisis de complejidad

5. **Opcional: Animar la soluciÃ³n** paso a paso

### API REST

El backend expone los siguientes endpoints:

#### 1. Backtracking
```bash
GET http://localhost:8080/api/knights-tour/backtracking?boardSize=5&startRow=0&startCol=0
```

#### 2. Warnsdorff
```bash
GET http://localhost:8080/api/knights-tour/warnsdorff?boardSize=8&startRow=0&startCol=0
```

#### 3. ProgramaciÃ³n DinÃ¡mica
```bash
POST http://localhost:8080/api/knights-tour/dynamic-programming
Content-Type: application/json

{
  "boardSize": 8,
  "startRow": 0,
  "startCol": 0,
  "maxMoves": 10,
  "pointsBoard": null
}
```

#### 4. Comparar Algoritmos
```bash
GET http://localhost:8080/api/knights-tour/compare?boardSize=6&startRow=0&startCol=0
```

#### 5. Generar Tablero de Puntos
```bash
GET http://localhost:8080/api/knights-tour/generate-points-board?boardSize=8
```

## ğŸ§® AnÃ¡lisis de Algoritmos

### 1ï¸âƒ£ Backtracking

**DescripciÃ³n:** Explora exhaustivamente todos los caminos posibles de forma recursiva. Si un camino no lleva a soluciÃ³n, retrocede (backtrack) y prueba otra ruta.

**Complejidad:**
- **Temporal:** O(8^(nÂ²)) - Exponencial
- **Espacial:** O(nÂ²)

**Ventajas:**
- âœ… Garantiza encontrar soluciÃ³n si existe
- âœ… Encuentra todas las soluciones posibles

**Desventajas:**
- âŒ Muy lento para tableros grandes (n > 6)
- âŒ Explora muchos caminos inÃºtiles

**Caso de uso:** Tableros pequeÃ±os (â‰¤ 6Ã—6) donde se necesita garantÃ­a de soluciÃ³n.

---

### 2ï¸âƒ£ HeurÃ­stica de Warnsdorff (Greedy)

**DescripciÃ³n:** En cada paso, elige la casilla con menor nÃºmero de movimientos disponibles (grado de accesibilidad). Esta estrategia "greedy" evita quedar atrapado en esquinas.

**Complejidad:**
- **Temporal:** O(nÂ²) - Lineal en nÃºmero de casillas
- **Espacial:** O(nÂ²)

**Ventajas:**
- âœ… Muy rÃ¡pido (milisegundos incluso para n=20)
- âœ… Alta tasa de Ã©xito (~90% en tableros grandes)
- âœ… No requiere backtracking

**Desventajas:**
- âŒ No garantiza soluciÃ³n en todos los casos
- âŒ Puede fallar en casos especÃ­ficos

**Caso de uso:** Tableros grandes (â‰¥ 8Ã—8) donde se prioriza velocidad.

---

### 3ï¸âƒ£ ProgramaciÃ³n DinÃ¡mica

**DescripciÃ³n:** Variante del problema donde se maximiza la suma de puntos visitados en exactamente K movimientos. Usa memoizaciÃ³n para evitar recalcular subproblemas.

**Complejidad:**
- **Temporal:** O(nÂ² Ã— k) donde k = nÃºmero de movimientos
- **Espacial:** O(nÂ² Ã— k)

**Ventajas:**
- âœ… SoluciÃ³n Ã³ptima para maximizaciÃ³n de puntos
- âœ… Evita recalcular subproblemas
- âœ… Eficiente para valores moderados de k

**Desventajas:**
- âŒ Alto uso de memoria para k grande
- âŒ Resuelve un problema diferente al Knight's Tour clÃ¡sico

**Caso de uso:** Problemas de optimizaciÃ³n con nÃºmero limitado de movimientos.

---

## ğŸ“Š Tabla Comparativa

| Algoritmo | Complejidad Temporal | Complejidad Espacial | Velocidad (8Ã—8) | GarantÃ­a de SoluciÃ³n |
|-----------|---------------------|---------------------|----------------|---------------------|
| **Backtracking** | O(8^(nÂ²)) | O(nÂ²) | ~5000ms | âœ… SÃ­ |
| **Warnsdorff** | O(nÂ²) | O(nÂ²) | ~5ms | âŒ No (alta probabilidad) |
| **Prog. DinÃ¡mica** | O(nÂ² Ã— k) | O(nÂ² Ã— k) | ~50ms (k=10) | âœ… SÃ­ (para maximizaciÃ³n) |

## ğŸ“ Conceptos de ProgramaciÃ³n 3 Aplicados

### TÃ©cnicas AlgorÃ­tmicas

1. **Backtracking (Vuelta AtrÃ¡s)**
   - RecursiÃ³n
   - Poda de Ã¡rbol de bÃºsqueda
   - ExploraciÃ³n exhaustiva

2. **Greedy (Algoritmos Voraces)**
   - ElecciÃ³n localmente Ã³ptima
   - HeurÃ­sticas
   - No siempre garantiza Ã³ptimo global

3. **ProgramaciÃ³n DinÃ¡mica**
   - Subestructura Ã³ptima
   - SuperposiciÃ³n de subproblemas
   - MemoizaciÃ³n
   - Bottom-up vs Top-down

### Estructuras de Datos

- Arrays multidimensionales (tablero)
- Listas (camino del caballo)
- Tablas de memoizaciÃ³n 3D

### AnÃ¡lisis de Complejidad

- NotaciÃ³n Big-O
- Complejidad temporal vs espacial
- Trade-offs entre algoritmos

## ğŸ“ Ejemplos de EjecuciÃ³n

### Ejemplo 1: Backtracking en 5Ã—5

```
Entrada: boardSize=5, startRow=0, startCol=0
Salida:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚  0 â”‚  3 â”‚ 14 â”‚  9 â”‚ 20 â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚ 13 â”‚  8 â”‚  1 â”‚  4 â”‚ 15 â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚  2 â”‚ 23 â”‚ 12 â”‚ 19 â”‚ 10 â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚  7 â”‚ 18 â”‚ 21 â”‚ 16 â”‚  5 â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚ 22 â”‚ 11 â”‚  6 â”‚ 24 â”‚ 17 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Tiempo: 2847ms
Pasos explorados: 1,234,567
```

### Ejemplo 2: Warnsdorff en 8Ã—8

```
Entrada: boardSize=8, startRow=0, startCol=0
Salida: [Tablero completo con recorrido]
Tiempo: 3ms
Pasos explorados: 64
```

## ğŸ› Troubleshooting

### Error: Puerto 8080 en uso

```bash
# En Mac/Linux
lsof -ti:8080 | xargs kill -9

# En Windows
netstat -ano | findstr :8080
taskkill /PID [PID] /F
```

### Error: Java no encontrado

Verificar instalaciÃ³n:
```bash
java -version
```

### Error: Maven no encontrado

Usar el wrapper de Maven incluido:
```bash
./mvnw spring-boot:run    # Mac/Linux
mvnw.cmd spring-boot:run  # Windows
```

## ğŸ“š Referencias

- **Knight's Tour Problem**: [Wikipedia](https://en.wikipedia.org/wiki/Knight%27s_tour)
- **Warnsdorff's Rule**: [GeeksforGeeks](https://www.geeksforgeeks.org/warnsdorffs-algorithm-knights-tour-problem/)
- **Backtracking**: [Introduction to Algorithms - Cormen et al.]
- **Dynamic Programming**: [CLRS Chapter 15]

## ğŸ‘¥ Autores

Trabajo PrÃ¡ctico - ProgramaciÃ³n 3 - UADE 2025

## ğŸ“„ Licencia

Este proyecto es material educativo para el curso de ProgramaciÃ³n 3.

---

## ğŸ¯ Preguntas Frecuentes del Coloquio

### 1. Â¿CÃ³mo funciona DFS en backtracking?

DFS (Depth-First Search) explora en profundidad cada rama del Ã¡rbol de decisiones antes de retroceder. En backtracking, intentamos todos los movimientos posibles desde una casilla recursivamente hasta encontrar soluciÃ³n o agotar opciones.

### 2. Â¿Por quÃ© Warnsdorff es mÃ¡s rÃ¡pido que Backtracking?

Warnsdorff usa una heurÃ­stica que reduce drÃ¡sticamente el espacio de bÃºsqueda. En lugar de probar todos los caminos (8^64 posibilidades), elige inteligentemente el prÃ³ximo movimiento, resultando en complejidad O(nÂ²) vs O(8^(nÂ²)).

### 3. Â¿CuÃ¡ndo usar ProgramaciÃ³n DinÃ¡mica?

PD es ideal cuando:
- Hay subestructura Ã³ptima
- Los subproblemas se superponen
- Se necesita optimizaciÃ³n (max/min)
- El espacio de estados es manejable

### 4. Â¿Diferencia entre Greedy y Backtracking?

- **Greedy**: Hace elecciÃ³n localmente Ã³ptima, no retrocede
- **Backtracking**: Explora todas las opciones, retrocede si falla

### 5. Â¿CuÃ¡l es mejor algoritmo?

Depende del caso:
- **Tableros pequeÃ±os + garantÃ­a**: Backtracking
- **Tableros grandes + velocidad**: Warnsdorff
- **OptimizaciÃ³n con restricciones**: ProgramaciÃ³n DinÃ¡mica

---

**Â¡Buena suerte con el coloquio! ğŸ€**

